/*
 * WARNING: This file was generated by BitByBitGenerator.xtend (see
 * generateUtilityClassFile()).
 * Do not edit.
 */
package com.viacron.greenball.app.bbb;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.Charset;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

import org.apache.log4j.Logger;

/**
 * The GreenballMessagesUtility class provides utility methods for the messaging system defined
 * by the GreenballMessages grammar.
 */
public class GreenballMessagesUtility {

   private static Logger log4j = Logger.getLogger(GreenballMessagesUtility.class);
   private static final char[] hexArray = "0123456789ABCDEF".toCharArray();
   private static final int BYTES_PER_ROW = 16;
   private static final int ROW_QTR1 = 3;
   private static final int ROW_HALF = 7;
   private static final int ROW_QTR2 = 11;
   private static final String LINE_SEPARATOR = System.lineSeparator();
   private static String[] hexChars = new String[] { "0", "1", "2", "3", "4", "5",
            "6", "7", "8", "9", "A", "B", "C", "D", "E", "F" };

   /**
    * This method converts an array of bytes to a hex string.
    */
   public static String bytesToHex(byte[] bytes) {
      char[] hexChars = new char[bytes.length * 3];

      for (int index = 0; index < bytes.length; index++) {
         int v = bytes[index] & 0xFF;
         hexChars[index * 3] = hexArray[v >>> 4];
         hexChars[index * 3 + 1] = hexArray[v & 0x0F];
         hexChars[index * 3 + 2] = ' ';
      }

      return new String(hexChars);
   }

   /**
    * This method returns a string from a byte array given an offset
    * in the byte array and a length.
    */
   public static String getString(byte[] byteArray, int offset, int len) {
      String result = "";

      for (int i = 0; i < len; i++) {
         result += (char) byteArray[offset + i];
      }

      return result;
   }

   /**
    * This method returns a boolean from a byte array given an offset in bits
    * in the byte array.
    */
   public static boolean getBoolean(byte[] byteArray, int offsetInBits) {
      int index = offsetInBits / 8;
      byte b = byteArray[index];
      int bitPosition = 7 - offsetInBits % 8;

      return ((b >> bitPosition) & 0x01) == 1 ? true : false;
   }

   /**
    * This method returns a byte from a byte array given an offset in bits into
    * the byte array.
    */
   public static byte getByte(byte[] byteArray, int offsetInBits) {
      int index = offsetInBits / 8;
      int bitPosition = offsetInBits % 8;
      int upper = 0;
      int lower = 0;

      if (bitPosition == 0) {
         upper = byteArray[index];
      } else if (bitPosition == 1) {
         upper = (byteArray[index] & 0x7f) << 1;
         lower = (byteArray[index + 1] >> 7) & 0x01;
      } else if (bitPosition == 2) {
         upper = (byteArray[index] & 0x3f) << 2;
         lower = (byteArray[index + 1] >> 6) & 0x03;
      } else if (bitPosition == 3) {
         upper = (byteArray[index] & 0x1f) << 3;
         lower = (byteArray[index + 1] >> 5) & 0x07;
      } else if (bitPosition == 4) {
         upper = (byteArray[index] & 0x0f) << 4;
         lower = (byteArray[index + 1] >> 4) & 0x0f;
      } else if (bitPosition == 5) {
         upper = (byteArray[index] & 0x07) << 5;
         lower = (byteArray[index + 1] >> 3) & 0x1f;
      } else if (bitPosition == 6) {
         upper = (byteArray[index] & 0x03) << 6;
         lower = (byteArray[index + 1] >> 2) & 0x3f;
      } else if (bitPosition == 7) {
         upper = (byteArray[index] & 0x01) << 7;
         lower = (byteArray[index + 1] >> 1) & 0x7f;
      }

      return (byte) (upper + lower);
   }

   /**
    * This method returns a character from a byte array given an offset in bits
    * in the byte array.
    */
   public static char getCharacter(byte[] byteArray, int offsetInBits) {
      byte[] bytes = new byte[2];

      for (int i = 0; i < 2; i++) {
         bytes[i] = getByte(byteArray, offsetInBits + i * 8);
      }

      return ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN).getChar();
   }

   /**
    * This method returns a short from a byte array given an offset in bits
    * in the byte array.
    */
   public static short getShort(byte[] byteArray, int offsetInBits) {
      byte[] bytes = new byte[2];

      for (int i = 0; i < 2; i++) {
         bytes[i] = getByte(byteArray, offsetInBits + i * 8);
      }

      return ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN).getShort();
   }

   /**
    * This method returns an integer from a byte array given an offset in bits
    * in the byte array.
    */
   public static int getInteger(byte[] byteArray, int offsetInBits) {
      byte[] bytes = new byte[4];

      for (int i = 0; i < 4; i++) {
         bytes[i] = getByte(byteArray, offsetInBits + i * 8);
      }

      return ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN).getInt();
   }

   /**
    * This method returns a long from a byte array given an offset in bits into
    * the byte array.
    */
   public static long getLong(byte[] byteArray, int offsetInBits) {
      byte[] bytes = new byte[8];

      for (int i = 0; i < 8; i++) {
         bytes[i] = getByte(byteArray, offsetInBits + i * 8);
      }

      return ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN).getLong();
   }

   /**
    * This method returns a float from a byte array given an offset in bits into
    * the byte array.
    */
   public static float getFloat(byte[] byteArray, int offsetInBits) {
      byte[] bytes = new byte[4];

      for (int i = 0; i < 4; i++) {
         bytes[i] = getByte(byteArray, offsetInBits + i * 8);
      }

      return ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN).getFloat();
   }

   /**
    * This method returns a Calendar from a byte array given an offset in bits
    * in the byte array.
    */
   public static Calendar getCalendar(byte[] byteArray, int offsetInBits) {

      long result = getLong(byteArray, offsetInBits);
      Date date = new Date(result);
      Calendar cal = Calendar.getInstance();
      cal.setTime(date);

      return cal;
   }

   /**
    * This method returns a date from a byte array given an offset
    * in the byte array.
    */
   public static Date getDate(byte[] byteArray, int offset) {

      long result = getLong(byteArray, offset);

      return new Date(result);
   }

   /**
    * This method returns a double from a byte array given an offset in bits
    * in the byte array.
    */
   public static double getDouble(byte[] byteArray, int offsetInBits) {
      byte[] bytes = new byte[8];

      for (int i = 0; i < 8; i++) {
         bytes[i] = getByte(byteArray, offsetInBits + i * 8);
      }

      return ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN).getDouble();
   }

   /**
    * This method inserts a bit field into a byte array at a given offset in bits
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bits in the byte array.
    * @param length The length of the bit field in bits.
    * @param value The value to be inserted.
    * @return The byte array.
    */
   public static byte[] insertBitfield(byte[] byteArray, int offsetInBits, int length, int value) {
      String binaryString = Integer.toBinaryString(value);
      if (binaryString.length() > length) {
         binaryString = binaryString.substring(0, length);
      }

      String paddedBinaryString = binaryString;

      if ((length - binaryString.length()) > 1) {
         paddedBinaryString = String.format(
               "%0" + (length - binaryString.length()) + "d" + "%s", 0,
               binaryString);
      }

      int bitCounter = offsetInBits;
      for (char c : paddedBinaryString.toCharArray()) {
         int index = bitCounter / 8;
         int shift = 7 - bitCounter % 8;

         if (c == '1') {
            byteArray[index] |= 1 << shift;
         } else {
            byteArray[index] &= ~(1 << shift);
         }

         bitCounter++;
      }

      return byteArray;
   }

   /**
    * This method inserts a calendar into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param calendar The calendar to be inserted.
    * @return The byte array.
    */
   public static byte[] insertCalendar(byte[] byteArray, int offset, Calendar calendar) {

      long lng = calendar.getTimeInMillis();
      byteArray = insertLong(byteArray, offset, lng);

      return byteArray;
   }

   /**
    * This method inserts a date into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param date The date to be inserted.
    * @return The byte array.
    */
   public static byte[] insertDate(byte[] byteArray, int offset, Date date) {

      long lng = date.getTime();
      byteArray = insertLong(byteArray, offset, lng);

      return byteArray;
   }

   /**
    * This method inserts a list of calendars into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param calendars The list of calendars to be inserted.
    * @return The byte array.
    */
   public static byte[] insertCalendars(byte[] byteArray, int offset, List<Calendar> calendars) {
      int index = 0;

      for (Calendar c : calendars) {
         byteArray = insertDate(byteArray, offset + index * 8, c.getTime());
         index++;
      }

      return byteArray;
   }

   /**
    * This method inserts a list of bytes into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param bytes The bytes to be inserted.
    * @return The byte array.
    */
   public static byte[] insertBytes(byte[] byteArray, int offset, List<Byte> bytes) {

      for (int i = 0; i < bytes.size(); i++) {
         byteArray[offset + i] = bytes.get(i);
      }

      return byteArray;
   }

   /**
    * This method inserts an array of bytes into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param bytes The bytes to be inserted.
    * @return The byte array.
    */
   public static byte[] insertBytes(byte[] byteArray, int offset, byte[] bytes) {

      int index = 0;
      for (byte b : bytes) {
         byteArray[offset + index] = b;
         index++;
      }

      return byteArray;
   }

   /**
    * This method inserts a list of booleans into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param booleans The list of boolean values to be inserted.
    * @return The byte array.
    */
   public static byte[] insertBooleans(byte[] byteArray, int offset, List<Boolean> booleans) {

      int index = 0;
      for (Boolean b : booleans) {
         byteArray = insertBitfield(byteArray, (offset + index) * 8, 1, (b == true ? 1 : 0));
         index++;
      }

      return byteArray;
   }

   /**
    * This method inserts a double into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param d The double value to be inserted.
    * @return The byte array.
    */
   public static byte[] insertDouble(byte[] byteArray, int offset, double d) {

      long lng = Double.doubleToLongBits(d);
      byteArray = insertLong(byteArray, offset, lng);

      return byteArray;
   }

   /**
    * This method inserts a list of doubles into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param doubles The list of double values to be inserted.
    * @return The byte array.
    */
   public static byte[] insertDoubles(byte[] byteArray, int offset, List<Double> doubles) {

      int index = 0;
      for (Double d : doubles) {
         byteArray = insertDouble(byteArray, offset + index * 8, d);
         index++;
      }

      return byteArray;
   }

   /**
    * This method inserts a long into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param lng The long value to be inserted.
    * @return The byte array.
    */
   public static byte[] insertLong(byte[] byteArray, int offset, long lng) {

      byte[] bytes = ByteBuffer.allocate(8).putLong(lng).array();
      byteArray = insertBytes(byteArray, offset, bytes);

      return byteArray;
   }

   /**
    * This method inserts a list of longs into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param longs The list of long values to be inserted.
    * @return The byte array.
    */
   public static byte[] insertLongs(byte[] byteArray, int offset, List<Long> longs) {

      int index = 0;
      for (Long lng : longs) {
         byteArray = insertLong(byteArray, offset + index * 8, lng);
         index++;
      }

      return byteArray;
   }

   /**
    * This method inserts an integer into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param integer The integer value to be inserted.
    * @return The byte array.
    */
   public static byte[] insertInteger(byte[] byteArray, int offset, int integer) {

      byte[] bytes = ByteBuffer.allocate(4).putInt(integer).array();
      byteArray = insertBytes(byteArray, offset, bytes);

      return byteArray;
   }

   /**
    * This method inserts a list of integers into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param integers The list of integer values to be inserted.
    * @return The byte array.
    */
   public static byte[] insertIntegers(byte[] byteArray, int offset, List<Integer> integers) {

      int index = 0;
      for (Integer integer : integers) {
         byteArray = insertInteger(byteArray, offset + index * 4, integer);
         index++;
      }

      return byteArray;
   }

   /**
    * This method inserts a short into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param shrt The short value to be inserted.
    * @return The byte array.
    */
   public static byte[] insertShort(byte[] byteArray, int offset, short shrt) {

      byte[] bytes = ByteBuffer.allocate(2).putShort(shrt).array();
      byteArray = insertBytes(byteArray, offset, bytes);

      return byteArray;
   }

   /**
    * This method inserts a list of shorts into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param shorts The list of short values to be inserted.
    * @return The byte array.
    */
   public static byte[] insertShorts(byte[] byteArray, int offset, List<Short> shorts) {

      int index = 0;
      for (Short shrt : shorts) {
         byteArray = insertShort(byteArray, offset + index * 2, shrt);
         index++;
      }

      return byteArray;
   }

   /**
    * This method inserts a float into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param flt The float value to be inserted.
    * @return The byte array.
    */
   public static byte[] insertFloat(byte[] byteArray, int offset, float flt) {

      byte[] bytes = ByteBuffer.allocate(4).putFloat(flt).array();
      byteArray = insertBytes(byteArray, offset, bytes);

      return byteArray;
   }

   /**
    * This method inserts a list of floats into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param floats The list of float values to be inserted.
    * @return The byte array.
    */
   public static byte[] insertFloats(byte[] byteArray, int offset, List<Float> floats) {

      int index = 0;
      for (Float f : floats) {
         byteArray = insertFloat(byteArray, offset + index * 4, f);
         index++;
      }

      return byteArray;
   }

   /**
    * This method inserts a char into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param c The integer value to be inserted.
    * @return The byte array.
    */
   public static byte[] insertCharacter(byte[] byteArray, int offset, char c) {

      for (int i = 0; i < 2; i++) {
         byte b = (byte) ((c >> (1 - i) * 8) & 0xff);
         byteArray = setByte(byteArray, offset + i, b);
      }

      return byteArray;
   }

   /**
    * This method inserts a list of chars into a byte array at a given offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param chars The list of char values to be inserted.
    * @return The byte array.
    */
   public static byte[] insertCharacters(byte[] byteArray, int offset, List<Character> chars) {

      int index = 0;
      for (Character c : chars) {
         byteArray = insertCharacter(byteArray, offset + index * 2, c);
         index++;
      }

      return byteArray;
   }

   /**
    * This method inserts a string into a byte array at a given an offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param string The string to be inserted.
    * @return The byte array.
    */
   public static byte[] insertString(byte[] byteArray, int offset, String string) {

      byte[] bytes = string.getBytes(Charset.forName("UTF-8"));

      int index = 0;
      for (byte b : bytes) {
         byteArray[offset + index] = b;
         index++;
      }

      return byteArray;
   }

   /**
    * This method inserts a list of strings into a byte array at a given an offset
    * in the byte array.
    * @param byteArray The byte array.
    * @param offset The offset in bytes in the byte array.
    * @param strings The list of string to be inserted.
    * @return The byte array.
    */
   public static byte[] insertStrings(byte[] byteArray, int offset, List<String> strings) {

      for (String string : strings) {
         byteArray = insertString(byteArray, offset, string);
         offset += string.getBytes(Charset.forName("UTF-8")).length;
      }

      return byteArray;
   }

   /**
    * This method sets a byte in a byte array at a certain offset
    * in the byte array.
    * @return The byte array.
    */
   public static byte[] setByte(byte[] byteArray, int offset, byte b) {
      byteArray[offset] = b;
      return byteArray;
   }

   /**
    * This method calculates a CRC-32 checksum for the specified array of bytes.
    * @param byteArray The byte array.
    * @param The number of bytes to consider when calculating the checksum.
    * @return The checksum.
    */
   public static long getChecksum(byte[] byteArray, int length) {
      Checksum checksum = new CRC32();
      checksum.update(byteArray, 0, length);
      return checksum.getValue();
   }

   /**
    * This method verifies a CRC-32 checksum for the specified array of bytes.
    * First the current checksum embedded in the last 8 bytes of the byte array
    * is retrieved. Then the checksum for the array is calculated and compared.
    * @param byteArray The byte array.
    * @return True if the checksum is valid.
    */
   public static boolean verifyChecksum(byte[] byteArray) {
      long checksum1 = getLong(byteArray, byteArray.length * 8 - 64);
      long checksum2 = getChecksum(byteArray, byteArray.length - 8);
      return checksum1 == checksum2;
   }

   /**
    * This method dumps a byte array as hex characters.
    * @param title The title.
    * @param buf The byte array buffer.
    * @param numBytes The number of bytes to dump.
    * @param return A string containing the dumped bytes.
    */
   public static String dumpHexData(String title, byte[] buf, int numBytes) {
      int rows;
      int residue;
      int i;
      int j;
      int labelSize;
      byte[] rowBuf = new byte[BYTES_PER_ROW + 2];
      String[] charBuf = new String[4];
      String result = title + " - " + numBytes + " bytes." + LINE_SEPARATOR;

      // There are 16 bytes per row.
      rows = numBytes >> 4;
      residue = numBytes & 0x0000000F;

      /*
       * Calculate the number of hex characters required to represent the row
       * label.
       */
      labelSize = log16(numBytes);

      for (i = 0; i < rows; i++) {
         int byteCount = (i * BYTES_PER_ROW);
         String rowLabel = buildRowLabel(byteCount, labelSize);

         result = result.concat(rowLabel + ": ");

         for (j = 0; j < BYTES_PER_ROW; j++) {
            rowBuf[j] = buf[(i * BYTES_PER_ROW) + j];

            charBuf[0] = hexChars[(rowBuf[j] >> 4) & 0x0F];
            charBuf[1] = hexChars[rowBuf[j] & 0x0F];

            result = result.concat(charBuf[0]);
            result = result.concat(charBuf[1]);
            result = result.concat(" ");

            if (j == ROW_QTR1 || j == ROW_HALF || j == ROW_QTR2) {
               result = result.concat(" ");
            }

            if (rowBuf[j] < 0x20 || rowBuf[j] > 0xD9) {
            rowBuf[j] = '.';
            }
         }

         String saveStr = new String(rowBuf, 0, j);
         result = result.concat(" | " + saveStr + " |" + LINE_SEPARATOR);
      }

      if (residue > 0) {
         int byteCount = (i * BYTES_PER_ROW);
         String rowLabel = buildRowLabel(byteCount, labelSize);
         result = result.concat(rowLabel + ": ");

         for (j = 0; j < residue; j++) {
            rowBuf[j] = buf[(i * BYTES_PER_ROW) + j];

            charBuf[0] = hexChars[(rowBuf[j] >> 4) & 0x0F];
            charBuf[1] = hexChars[rowBuf[j] & 0x0F];

            result = result.concat(charBuf[0]);
            result = result.concat(charBuf[1]);
            result = result.concat(" ");

            if (j == ROW_QTR1 || j == ROW_HALF || j == ROW_QTR2) {
               result = result.concat(" ");
            }

            if (rowBuf[j] < 0x20 || rowBuf[j] > 0xD9) {
               rowBuf[j] = '.';
            }
         }

         for ( /* j INHERITED */; j < BYTES_PER_ROW; j++) {
            rowBuf[j] = ' ';
            result = result.concat("   ");
            if (j == ROW_QTR1 || j == ROW_HALF || j == ROW_QTR2) {
               result = result.concat(" ");
            }
         }

         String saveStr = new String(rowBuf, 0, j);
         result = result.concat(" | " + saveStr + " |" + LINE_SEPARATOR);
      }

      return result;
   }

   /*
    * This method builds the label the proceeds each row of data. The index and
    * shift are calculated on the fly to obtain a result like this:
    * idx_buf[0] = hexChars[((hexVal >> 12) & 0xf)];
    * idx_buf[1] = hexChars[((hexVal >> 8) & 0xf)];
    * idx_buf[2] = hexChars[((hexVal >> 4) & 0xf)];
    * idx_buf[3] = hexChars[(hexVal & 0xf)];
    *
    * The array of bytes is then converted to a string and returned.
    * @param byteCount The byte count.
    * @param labelSize The label size.
    */
   private static String buildRowLabel(int byteCount, int labelSize) {
      String result = "";
      
      for (int c = 0; c < labelSize; c++) {
         int shift = c * 4;
         result = hexChars[((byteCount >> shift) & 0xf)] + result;
      }

      return result;
   }

   /*
    * This method calculates the minimum number of hex characters required to
    * represent the given value.
    */
   private static int log16(int value) {
      int bits = Integer.SIZE
            - Integer.numberOfLeadingZeros(value > 0 ? value - 1 : value);
      int hex = (bits - 1) / 4 + 1;

      return hex;
   }
}
