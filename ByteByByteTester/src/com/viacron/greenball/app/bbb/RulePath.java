/*
 * WARNING: This file was generated by BitByBitGenerator.xtend (see
 * generateClassFile()). 
 * Do not edit.
 */
package com.viacron.greenball.app.bbb;

import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
/**
 * The RulePath class is a SubType referenced by message objects defined
 * by the GreenballMessages grammar.
 */
public class RulePath {
   private static final int ID = GreenballMessagesEnum.RULE_PATH.getId();

   /**
    * The number of bits required to represent the RulePathEnum IDs.
    * # of attributes: 5
    * # of PEnumRefs: 0
    */
   private static final int ID_BITS = 3;

   private static GreenballMessagesDirectoryEntry[] theDirectory;
   private static final int DIRECTORY_OFFSET = 2;

   private static Logger log4j = Logger.getLogger(RulePath.class);

   // Entered buildClassEnum()
   private enum RulePathEnum {
      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      CLASS_NAME(0, -1, 0, true),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      XREF_CLASS_NAME(1, -1, 0, true),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      ID(2, -1, 0, true),

      // sizeInBits: 8
      CROSS_REFERENCE(3, 3, 0, false),

      // sizeInBits: 8
      MULTI(4, 11, 0, false);

      private final int id;
      private final int offsetInBits;
      private int length;
      private boolean isDirectoryEntry;

      RulePathEnum(int id, int offsetInBits, int length, boolean isDirectoryEntry) {
         this.id = id;
         this.offsetInBits = offsetInBits;
         this.length = length;
         this.isDirectoryEntry = isDirectoryEntry;
      }

      public int getId() {
         return this.id;
      }

      public int getOffsetInBits() {
         return this.offsetInBits;
      }

      public int getLength() {
         return this.length;
      }

      public void setLength(int length) {
         this.length = length;
      }
   } // Leaving buildClassEnum()

   /*
    * The instance variables.
    * See buildInstanceVariables() in JBitByBitGenerator.java.
    */
   private String className;
   private String xrefClassName;
   private String id;
   private boolean crossReference;
   private boolean multi;

   private String theErrorMsg;

   /**
    * The RulePath no-arg constructor.
    */
   public RulePath() {}

   /**
    * The RulePath constructor.
    * See buildParameterAnnotations() in JBitByBitGenerator.java.
    *
    * @param className The className message attribute.
    * @param xrefClassName The xrefClassName message attribute.
    * @param id The id message attribute.
    * @param crossReference The crossReference message attribute.
    * @param multi The multi message attribute.
    */
   public RulePath(String className,
                   String xrefClassName,
                   String id,
                   Boolean crossReference,
                   Boolean multi) {
      // Entered buildParameterAssignments()
      this.setClassName(className);
      this.setXrefClassName(xrefClassName);
      this.setId(id);
      this.setCrossReference(crossReference);
      this.setMulti(multi);
      // Leaving buildParameterAssignments()
   }

   /**
    * The RulePath copy constructor.
    */
   public RulePath(RulePath rulePath) {
      // Entered buildCopyConstructorParameterAssignments()
      this.setClassName(rulePath.getClassName());
      this.setXrefClassName(rulePath.getXrefClassName());
      this.setId(rulePath.getId());
      this.setCrossReference(rulePath.getCrossReference());
      this.setMulti(rulePath.getMulti());
      // Leaving buildCopyConstructorParameterAssignments()
   }

   // Entered buildSetErrorMsgMethod()
   private void setErrorMsg(String errorMsg) {
      theErrorMsg = errorMsg;
   }
   // Leaving buildSetErrorMsgMethod()

   // Entered buildGetErrorMsgMethod()
   /**
    * This method returns the error message or null if no error
    * occurred.
    */
   public String getErrorMsg() {
      return theErrorMsg;
   }
   // Leaving buildGetErrorMsgMethod()

   // Entered buildPackMethod()
   /**
    * This method packs a RulePath object into a byte array. If a required attribute is not
    * provided an exception will be thrown.
    *
    * @return A byte array which represents a RulePath message object.
    * @throws MissingAttributeException
    */
   public byte[] pack() throws MissingAttributeException {
      final String METHOD = "pack()";
      log4j.debug("Entered " + METHOD);

      int byteArraySize = getRulePathSize();
      log4j.debug("byteArraySize: " + byteArraySize);
      byte[] bb = new byte[byteArraySize];

      /*
       * Convert object to byte array.
       */
      int offset = 0;

      if (this.getCrossReference() != null) {
         bb = GreenballMessagesUtility.insertBitfield(bb, offset * 8, 1, this.getCrossReference() == true ? 1 : 0);
         offset += 1;
      } else {
         /*
          * Missing required attribute, generate an error message and throw
          * an exception.
          */
         setErrorMsg("Error packing object. The attribute \"crossReference\" is required, but no value was provided.");
         log4j.error(getErrorMsg());
         throw new MissingAttributeException(getErrorMsg());
      }

      if (this.getMulti() != null) {
         bb = GreenballMessagesUtility.insertBitfield(bb, offset * 8, 1, this.getMulti() == true ? 1 : 0);
         offset += 1;
      } else {
         /*
          * Missing required attribute, generate an error message and throw
          * an exception.
          */
         setErrorMsg("Error packing object. The attribute \"multi\" is required, but no value was provided.");
         log4j.error(getErrorMsg());
         throw new MissingAttributeException(getErrorMsg());
      }


      RulePathEnum.CLASS_NAME.setLength(this.getClassName().length());
      RulePathEnum.XREF_CLASS_NAME.setLength(this.getXrefClassName().length());
      RulePathEnum.ID.setLength(this.getId().length());

      int directorySize = getRulePathDirectorySize();
      if (directorySize != 0) {
         // Create the directory
         theDirectory = new GreenballMessagesDirectoryEntry[directorySize];
         for (int i = 0; i < directorySize; i++) {
            theDirectory[i] = new GreenballMessagesDirectoryEntry();
         }

         // Fill the directory
         int index = 0;
         offset = DIRECTORY_OFFSET
               + GreenballMessagesDirectoryEntry.DIRECTORY_ENTRY_SIZE_IN_BYTES
               * theDirectory.length;

         for (RulePathEnum rulePathEnum : RulePathEnum.values()) {
            if (rulePathEnum.isDirectoryEntry == true) {
               int id = rulePathEnum.getId();
               int length = rulePathEnum.getLength();

               theDirectory[index].setId(id);
               theDirectory[index].setLength(length);
               theDirectory[index].setOffset(offset);

               // Insert the data
               if (id == RulePathEnum.CLASS_NAME.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "className", offset));
                  bb = GreenballMessagesUtility.insertString(bb, offset, getClassName());
                  offset += length * 1;
               }
               else if (id == RulePathEnum.XREF_CLASS_NAME.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "xrefClassName", offset));
                  bb = GreenballMessagesUtility.insertString(bb, offset, getXrefClassName());
                  offset += length * 1;
               }
               else if (id == RulePathEnum.ID.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "id", offset));
                  bb = GreenballMessagesUtility.insertString(bb, offset, getId());
                  offset += length * 1;
               }
               index++;
            }
         }

         // Insert the directory
         offset = DIRECTORY_OFFSET;
         for (GreenballMessagesDirectoryEntry directoryEntry : theDirectory) {
            bb = GreenballMessagesUtility.insertInteger(bb, offset, directoryEntry.getId());
            bb = GreenballMessagesUtility.insertInteger(bb, offset + 4, directoryEntry.getLength());
            bb = GreenballMessagesUtility.insertInteger(bb, offset + 8, directoryEntry.getOffset());

            offset += GreenballMessagesDirectoryEntry.DIRECTORY_ENTRY_SIZE_IN_BYTES;
            index++;
         }

      }
      log4j.debug("Leaving " + METHOD);
      return bb;
   }
   // Leaving buildPackMethod()

   // Entered buildUnpackMethod()
   /**
    * This method unpacks a byte array containing a RulePath object.
    *
    * @return The byte array as a RulePath message object.
    */
   public RulePath unpack(byte[] ba) {
      final String METHOD = "unpack()";
      log4j.debug("Entered " + METHOD);

      RulePath rulePath = new RulePath();

      rulePath.setCrossReference(GreenballMessagesUtility.getBoolean(ba, RulePathEnum.CROSS_REFERENCE.getOffsetInBits()));
      rulePath.setMulti(GreenballMessagesUtility.getBoolean(ba, RulePathEnum.MULTI.getOffsetInBits()));

      // Get the directory
      int directorySize = getRulePathDirectorySize();
      theDirectory = new GreenballMessagesDirectoryEntry[directorySize];
      int dirOffset = DIRECTORY_OFFSET;

      for (int entry = 0 ; entry < directorySize; entry++) {
         GreenballMessagesDirectoryEntry directoryEntry = new GreenballMessagesDirectoryEntry();

         int id = GreenballMessagesUtility.getInteger(ba, dirOffset * 8);
         directoryEntry.setId(id);
         int length = GreenballMessagesUtility.getInteger(ba, (dirOffset + 4) * 8);
         directoryEntry.setLength(length);
         int offset = GreenballMessagesUtility.getInteger(ba, (dirOffset + 8) * 8);
         directoryEntry.setOffset(offset);

         theDirectory[entry] = directoryEntry;

         dirOffset += GreenballMessagesDirectoryEntry.DIRECTORY_ENTRY_SIZE_IN_BYTES;
      }

      for (GreenballMessagesDirectoryEntry directoryEntry : theDirectory) {
         int id = directoryEntry.getId();
         int offset = directoryEntry.getOffset();
         int length = directoryEntry.getLength();

         if (id == RulePathEnum.CLASS_NAME.getId()) {
            rulePath.setClassName(GreenballMessagesUtility.getString(ba, offset, length));
         }
         else if (id == RulePathEnum.XREF_CLASS_NAME.getId()) {
            rulePath.setXrefClassName(GreenballMessagesUtility.getString(ba, offset, length));
         }
         else if (id == RulePathEnum.ID.getId()) {
            rulePath.setId(GreenballMessagesUtility.getString(ba, offset, length));
         }
      }

      log4j.debug("Leaving " + METHOD);
      return rulePath;
   }
   // Leaving buildUnpackMethod()

   /**
    * This method sets the className attribute. Setting of this value is required.
    * @param className The className attribute.
    */
   public void setClassName(String className) {
      this.className = className;
   }

   /**
    * This method sets the xrefClassName attribute. Setting of this value is optional.
    * @param xrefClassName The xrefClassName attribute.
    */
   public void setXrefClassName(String xrefClassName) {
      this.xrefClassName = xrefClassName;
   }

   /**
    * This method sets the id attribute. Setting of this value is required.
    * @param id The id attribute.
    */
   public void setId(String id) {
      this.id = id;
   }

   /**
    * This method sets the crossReference attribute. Setting of this value is required.
    * @param crossReference The crossReference attribute.
    */
   public void setCrossReference(Boolean crossReference) {
      this.crossReference = crossReference;
   }

   /**
    * This method sets the multi attribute. Setting of this value is required.
    * @param multi The multi attribute.
    */
   public void setMulti(Boolean multi) {
      this.multi = multi;
   }

   /**
    * This method gets the className attribute. The className attribute is a required attribute.
    */
   public String getClassName() {
      return this.className;
   }

   /**
    * This method gets the xrefClassName attribute. The xrefClassName attribute is an optional attribute.
    */
   public String getXrefClassName() {
      return this.xrefClassName;
   }

   /**
    * This method gets the id attribute. The id attribute is a required attribute.
    */
   public String getId() {
      return this.id;
   }

   /**
    * This method gets the crossReference attribute. The crossReference attribute is a required attribute.
    */
   public Boolean getCrossReference() {
      return this.crossReference;
   }

   /**
    * This method gets the multi attribute. The multi attribute is a required attribute.
    */
   public Boolean getMulti() {
      return this.multi;
   }

   /**
    * This method gets the size of the directory.
    */
   private int getRulePathDirectorySize() {
      int directorySize = 0;

      // className
      directorySize++;
      // xrefClassName
      directorySize++;
      // id
      directorySize++;

      return directorySize;
   }


   /**
    * This method gets the size of the RulePath object.
    * @return The size in bytes.
    */
   public int getRulePathSize() {
      int size = 0;

      int directorySize = getRulePathDirectorySize();
      size += directorySize * GreenballMessagesDirectoryEntry.DIRECTORY_ENTRY_SIZE_IN_BYTES;
      // Add size of className
      size += (getClassName() != null ? getClassName().length() : 0);
      // Add size of xrefClassName
      size += (getXrefClassName() != null ? getXrefClassName().length() : 0);
      // Add size of id
      size += (getId() != null ? getId().length() : 0);
      // Add size of crossReference
      size += 1;
      // Add size of multi
      size += 1;

      return size;
   }

   @Override
   public String toString() {
      StringBuilder result = new StringBuilder();
      String NEW_LINE = System.getProperty("line.separator");

      result.append(this.getClass().getSimpleName() + " Object {" + NEW_LINE);
      result.append(" className: " + className + NEW_LINE);
      result.append(" xrefClassName: " + xrefClassName + NEW_LINE);
      result.append(" id: " + id + NEW_LINE);
      result.append(" crossReference: " + crossReference + NEW_LINE);
      result.append(" multi: " + multi + NEW_LINE);

      result.append("} ");

      return result.toString();
   }

   /**
    * The hashCode method returns this object's hashCode.
    */
   @Override
   public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result
         + ((String) className).hashCode();
      result = prime * result
         + ((String) xrefClassName).hashCode();
      result = prime * result
         + ((String) id).hashCode();
      result = prime * result
         + ((Boolean) crossReference).hashCode();
      result = prime * result
         + ((Boolean) multi).hashCode();
      return result;
   }

   /**
    * The equals method checks for equality. 
    */
   public boolean equals(Object obj) {
      if (obj == this) return true;
      if (obj == null) return false;
      if (getClass() != obj.getClass()) return false;

      RulePath rulePath = (RulePath) obj;
      if (!rulePath.getClassName().equals(this.getClassName())) {
         return false;
      }

      if (rulePath.getXrefClassName() == null && this.getXrefClassName() != null) {
         return false;
      }
      else if (rulePath.getXrefClassName() != null && this.getXrefClassName() == null) {
         return false;
      }
      else if (rulePath.getXrefClassName() != null && 
      !rulePath.getXrefClassName().equals(this.getXrefClassName())) {
         return false;
      }

      if (!rulePath.getId().equals(this.getId())) {
         return false;
      }

      if (rulePath.getCrossReference() != this.getCrossReference()) {
         return false;
      }

      if (rulePath.getMulti() != this.getMulti()) {
         return false;
      }

      return true;
   }
}
