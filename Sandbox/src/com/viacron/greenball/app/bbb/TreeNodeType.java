/*
 * WARNING: This file was generated by BitByBitGenerator.xtend (see
 * generateClassFile()). 
 * Do not edit.
 */
package com.viacron.greenball.app.bbb;

import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
/**
 * The TreeNodeType class is a SubType referenced by message objects defined
 * by the GreenballMessages grammar.
 */
public class TreeNodeType {
   private static final int ID = GreenballMessagesEnum.TREE_NODE_TYPE.getId();

   /**
    * The number of bits required to represent the TreeNodeTypeEnum IDs.
    * # of attributes: 20
    * # of PEnumRefs: 0
    */
   private static final int ID_BITS = 5;

   private static GreenballMessagesDirectoryEntry[] theDirectory;
   private static final int DIRECTORY_OFFSET = 24;

   private static Logger log4j = Logger.getLogger(TreeNodeType.class);

   // Entered buildClassEnum()
   private enum TreeNodeTypeEnum {
      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      PARENT(0, -1, 0, true),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      CHILDREN(1, -1, 0, true),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      PREFIX(2, -1, 0, true),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      LABEL(3, -1, 0, true),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      FIELD_NAME(4, -1, 0, true),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      CLASS_NAME(5, -1, 0, true),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      SOURCE(6, -1, 0, true),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      CROSSLINK(7, -1, 0, true),

      // sizeInBits: 32
      USAGE_COUNTER(8, 0, 0, false),

      // sizeInBits: 32
      LEVEL(9, 32, 0, false),

      // sizeInBits: 32
      NODE_STATE(10, 64, 0, false),

      // sizeInBits: 64
      SN(11, 96, 0, false),

      // sizeInBits: 8
      XREF(12, 160, 0, false),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      RULE_IDS(13, -1, 0, true),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      CROSS_REFERENCE(14, -1, 0, true),

      // sizeInBits: 8
      MULTI(15, 168, 0, false),

      // sizeInBits: 8
      LABELABLE(16, 176, 0, false),

      // sizeInBits: 8
      EXPANDED(17, 184, 0, false),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      ID(18, -1, 0, true),

      // This is a directory item. It's offset and length cannot be determined
      // until runtime.
      PARENT_ID(19, -1, 0, true);

      private final int id;
      private final int offsetInBits;
      private int length;
      private boolean isDirectoryEntry;

      TreeNodeTypeEnum(int id, int offsetInBits, int length, boolean isDirectoryEntry) {
         this.id = id;
         this.offsetInBits = offsetInBits;
         this.length = length;
         this.isDirectoryEntry = isDirectoryEntry;
      }

      public int getId() {
         return this.id;
      }

      public int getOffsetInBits() {
         return this.offsetInBits;
      }

      public int getLength() {
         return this.length;
      }

      public void setLength(int length) {
         this.length = length;
      }
   } // Leaving buildClassEnum()

   /*
    * The instance variables.
    * See buildInstanceVariables() in JBitByBitGenerator.java.
    */
   private TreeNodeType parent;
   private List<TreeNodeType> children;
   private String prefix;
   private String label;
   private String fieldName;
   private String className;
   private String source;
   private String crosslink;
   private int usageCounter;
   private int level;
   private int nodeState;
   private long sn;
   private boolean xref;
   private List<String> ruleIds;
   private String crossReference;
   private boolean multi;
   private boolean labelable;
   private boolean expanded;
   private String id;
   private String parentId;

   private String theErrorMsg;

   /**
    * The TreeNodeType no-arg constructor.
    */
   public TreeNodeType() {}

   /**
    * The TreeNodeType constructor.
    * See buildParameterAnnotations() in JBitByBitGenerator.java.
    *
    * @param parent The parent message attribute.
    * @param children The children message attribute.
    * @param prefix The prefix message attribute.
    * @param label The label message attribute.
    * @param fieldName The fieldName message attribute.
    * @param className The className message attribute.
    * @param source The source message attribute.
    * @param crosslink The crosslink message attribute.
    * @param usageCounter The usageCounter message attribute.
    * @param level The level message attribute.
    * @param nodeState The nodeState message attribute.
    * @param sn The sn message attribute.
    * @param xref The xref message attribute.
    * @param ruleIds The ruleIds message attribute.
    * @param crossReference The crossReference message attribute.
    * @param multi The multi message attribute.
    * @param labelable The labelable message attribute.
    * @param expanded The expanded message attribute.
    * @param id The id message attribute.
    * @param parentId The parentId message attribute.
    */
   public TreeNodeType(TreeNodeType parent, List<TreeNodeType> children,
                       String prefix,
                       String label,
                       String fieldName,
                       String className,
                       String source,
                       String crosslink,
                       Integer usageCounter,
                       Integer level,
                       Integer nodeState,
                       Long sn,
                       Boolean xref,
                       List<String> ruleIds,
                       String crossReference,
                       Boolean multi,
                       Boolean labelable,
                       Boolean expanded,
                       String id,
                       String parentId) {
      // Entered buildParameterAssignments()
      this.setParent(parent);
      this.setChildren(children);
      this.setPrefix(prefix);
      this.setLabel(label);
      this.setFieldName(fieldName);
      this.setClassName(className);
      this.setSource(source);
      this.setCrosslink(crosslink);
      this.setUsageCounter(usageCounter);
      this.setLevel(level);
      this.setNodeState(nodeState);
      this.setSn(sn);
      this.setXref(xref);
      this.setRuleIds(ruleIds);
      this.setCrossReference(crossReference);
      this.setMulti(multi);
      this.setLabelable(labelable);
      this.setExpanded(expanded);
      this.setId(id);
      this.setParentId(parentId);
      // Leaving buildParameterAssignments()
   }

   /**
    * The TreeNodeType copy constructor.
    */
   public TreeNodeType(TreeNodeType treeNodeType) {
      // Entered buildCopyConstructorParameterAssignments()
      this.setParent(new TreeNodeType(treeNodeType));
      for(TreeNodeType tmpTreeNodeType : treeNodeType.getChildren()) {
         this.getChildren().add(new TreeNodeType(tmpTreeNodeType));
      }
      this.setPrefix(treeNodeType.getPrefix());
      this.setLabel(treeNodeType.getLabel());
      this.setFieldName(treeNodeType.getFieldName());
      this.setClassName(treeNodeType.getClassName());
      this.setSource(treeNodeType.getSource());
      this.setCrosslink(treeNodeType.getCrosslink());
      this.setUsageCounter(treeNodeType.getUsageCounter());
      this.setLevel(treeNodeType.getLevel());
      this.setNodeState(treeNodeType.getNodeState());
      this.setSn(treeNodeType.getSn());
      this.setXref(treeNodeType.getXref());
      this.setRuleIds(treeNodeType.getRuleIds());
      this.setCrossReference(treeNodeType.getCrossReference());
      this.setMulti(treeNodeType.getMulti());
      this.setLabelable(treeNodeType.getLabelable());
      this.setExpanded(treeNodeType.getExpanded());
      this.setId(treeNodeType.getId());
      this.setParentId(treeNodeType.getParentId());
      // Leaving buildCopyConstructorParameterAssignments()
   }

   // Entered buildSetErrorMsgMethod()
   private void setErrorMsg(String errorMsg) {
      theErrorMsg = errorMsg;
   }
   // Leaving buildSetErrorMsgMethod()

   // Entered buildGetErrorMsgMethod()
   /**
    * This method returns the error message or null if no error
    * occurred.
    */
   public String getErrorMsg() {
      return theErrorMsg;
   }
   // Leaving buildGetErrorMsgMethod()

   // Entered buildPackMethod()
   /**
    * This method packs a TreeNodeType object into a byte array. If a required attribute is not
    * provided an exception will be thrown.
    *
    * @return A byte array which represents a TreeNodeType message object.
    * @throws MissingAttributeException
    */
   public byte[] pack() throws MissingAttributeException {
      final String METHOD = "pack()";
      log4j.debug("Entered " + METHOD);

      int byteArraySize = getTreeNodeTypeSize();
      log4j.debug("byteArraySize: " + byteArraySize);
      byte[] bb = new byte[byteArraySize];

      /*
       * Convert object to byte array.
       */
      int offset = 0;

      if (this.getUsageCounter() != null) {
         log4j.debug(String.format("inserting %s at offset %d", "usageCounter", offset));
         bb = GreenballMessagesUtility.insertInteger(bb, offset, this.getUsageCounter());
         offset += 4;
      } else {
         /*
          * Missing required attribute, generate an error message and throw
          * an exception.
          */
         setErrorMsg("Error packing object. The attribute \"usageCounter\" is required, but no value was provided.");
         log4j.error(getErrorMsg());
         throw new MissingAttributeException(getErrorMsg());
      }

      if (this.getLevel() != null) {
         log4j.debug(String.format("inserting %s at offset %d", "level", offset));
         bb = GreenballMessagesUtility.insertInteger(bb, offset, this.getLevel());
         offset += 4;
      } else {
         /*
          * Missing required attribute, generate an error message and throw
          * an exception.
          */
         setErrorMsg("Error packing object. The attribute \"level\" is required, but no value was provided.");
         log4j.error(getErrorMsg());
         throw new MissingAttributeException(getErrorMsg());
      }

      if (this.getNodeState() != null) {
         log4j.debug(String.format("inserting %s at offset %d", "nodeState", offset));
         bb = GreenballMessagesUtility.insertInteger(bb, offset, this.getNodeState());
         offset += 4;
      } else {
         /*
          * Missing required attribute, generate an error message and throw
          * an exception.
          */
         setErrorMsg("Error packing object. The attribute \"nodeState\" is required, but no value was provided.");
         log4j.error(getErrorMsg());
         throw new MissingAttributeException(getErrorMsg());
      }

      if (this.getSn() != null) {
         log4j.debug(String.format("inserting %s at offset %d", "sn", offset));
         bb = GreenballMessagesUtility.insertLong(bb, offset, this.getSn());
         offset += 8;
      } else {
         /*
          * Missing required attribute, generate an error message and throw
          * an exception.
          */
         setErrorMsg("Error packing object. The attribute \"sn\" is required, but no value was provided.");
         log4j.error(getErrorMsg());
         throw new MissingAttributeException(getErrorMsg());
      }

      if (this.getXref() != null) {
         log4j.debug(String.format("inserting %s at offset %d", "xref", offset));
         bb = GreenballMessagesUtility.insertBitfield(bb, offset * 8, 1, this.getXref() == true ? 1 : 0);
         offset += 1;
      } else {
         /*
          * Missing required attribute, generate an error message and throw
          * an exception.
          */
         setErrorMsg("Error packing object. The attribute \"xref\" is required, but no value was provided.");
         log4j.error(getErrorMsg());
         throw new MissingAttributeException(getErrorMsg());
      }

      if (this.getMulti() != null) {
         log4j.debug(String.format("inserting %s at offset %d", "multi", offset));
         bb = GreenballMessagesUtility.insertBitfield(bb, offset * 8, 1, this.getMulti() == true ? 1 : 0);
         offset += 1;
      } else {
         /*
          * Missing required attribute, generate an error message and throw
          * an exception.
          */
         setErrorMsg("Error packing object. The attribute \"multi\" is required, but no value was provided.");
         log4j.error(getErrorMsg());
         throw new MissingAttributeException(getErrorMsg());
      }

      if (this.getLabelable() != null) {
         log4j.debug(String.format("inserting %s at offset %d", "labelable", offset));
         bb = GreenballMessagesUtility.insertBitfield(bb, offset * 8, 1, this.getLabelable() == true ? 1 : 0);
         offset += 1;
      } else {
         /*
          * Missing required attribute, generate an error message and throw
          * an exception.
          */
         setErrorMsg("Error packing object. The attribute \"labelable\" is required, but no value was provided.");
         log4j.error(getErrorMsg());
         throw new MissingAttributeException(getErrorMsg());
      }

      if (this.getExpanded() != null) {
         log4j.debug(String.format("inserting %s at offset %d", "expanded", offset));
         bb = GreenballMessagesUtility.insertBitfield(bb, offset * 8, 1, this.getExpanded() == true ? 1 : 0);
         offset += 1;
      } else {
         /*
          * Missing required attribute, generate an error message and throw
          * an exception.
          */
         setErrorMsg("Error packing object. The attribute \"expanded\" is required, but no value was provided.");
         log4j.error(getErrorMsg());
         throw new MissingAttributeException(getErrorMsg());
      }


      TreeNodeTypeEnum.PARENT.setLength(this.getParent().getTreeNodeTypeSize());
      TreeNodeTypeEnum.CHILDREN.setLength(this.getChildren().size());
      TreeNodeTypeEnum.PREFIX.setLength(this.getPrefix() != null ? this.getPrefix().length() : 0);
      TreeNodeTypeEnum.LABEL.setLength(this.getLabel() != null ? this.getLabel().length() : 0);
      TreeNodeTypeEnum.FIELD_NAME.setLength(this.getFieldName() != null ? this.getFieldName().length() : 0);
      TreeNodeTypeEnum.CLASS_NAME.setLength(this.getClassName() != null ? this.getClassName().length() : 0);
      TreeNodeTypeEnum.SOURCE.setLength(this.getSource() != null ? this.getSource().length() : 0);
      TreeNodeTypeEnum.CROSSLINK.setLength(this.getCrosslink() != null ? this.getCrosslink().length() : 0);
      TreeNodeTypeEnum.RULE_IDS.setLength(this.getRuleIds() != null ? this.getRuleIds().size() : 0);
      TreeNodeTypeEnum.CROSS_REFERENCE.setLength(this.getCrossReference() != null ? this.getCrossReference().length() : 0);
      TreeNodeTypeEnum.ID.setLength(this.getId() != null ? this.getId().length() : 0);
      TreeNodeTypeEnum.PARENT_ID.setLength(this.getParentId() != null ? this.getParentId().length() : 0);

      int directorySize = getTreeNodeTypeDirectorySize();
      if (directorySize != 0) {
         // Create the directory
         theDirectory = new GreenballMessagesDirectoryEntry[directorySize];
         for (int i = 0; i < directorySize; i++) {
            theDirectory[i] = new GreenballMessagesDirectoryEntry();
         }

         // Fill the directory
         int index = 0;
         offset = DIRECTORY_OFFSET
               + GreenballMessagesDirectoryEntry.DIRECTORY_ENTRY_SIZE_IN_BYTES
               * theDirectory.length;

         for (TreeNodeTypeEnum treeNodeTypeEnum : TreeNodeTypeEnum.values()) {
            if (treeNodeTypeEnum.isDirectoryEntry == true) {
               int id = treeNodeTypeEnum.getId();
               int length = treeNodeTypeEnum.getLength();

               theDirectory[index].setId(id);
               theDirectory[index].setLength(length);
               theDirectory[index].setOffset(offset);

               // Insert the data
               if (id == TreeNodeTypeEnum.PARENT.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "parent", offset));
                  byte[] bytes = this.getParent().pack();
                  bb = GreenballMessagesUtility.insertBytes(bb, offset, bytes);
                  offset += bytes.length;
               }
               else if (id == TreeNodeTypeEnum.CHILDREN.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "children", offset));
                  for (TreeNodeType treeNodeType : this.children) {
                     byte[] bytes = treeNodeType.pack();
                     bb = GreenballMessagesUtility.insertBytes(bb, offset, bytes);

                     theDirectory[index].setId(id);
                     theDirectory[index].setLength(bytes.length);
                     theDirectory[index].setOffset(offset);

                     offset += bytes.length;
                     index++;
                  }
               }
               else if (id == TreeNodeTypeEnum.PREFIX.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "prefix", offset));
                  if (getPrefix() != null) {
                     bb = GreenballMessagesUtility.insertString(bb, offset, getPrefix());
                     offset += length * 1;
                  }
               }
               else if (id == TreeNodeTypeEnum.LABEL.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "label", offset));
                  if (getLabel() != null) {
                     bb = GreenballMessagesUtility.insertString(bb, offset, getLabel());
                     offset += length * 1;
                  }
               }
               else if (id == TreeNodeTypeEnum.FIELD_NAME.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "fieldName", offset));
                  if (getFieldName() != null) {
                     bb = GreenballMessagesUtility.insertString(bb, offset, getFieldName());
                     offset += length * 1;
                  }
               }
               else if (id == TreeNodeTypeEnum.CLASS_NAME.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "className", offset));
                  if (getClassName() != null) {
                     bb = GreenballMessagesUtility.insertString(bb, offset, getClassName());
                     offset += length * 1;
                  }
               }
               else if (id == TreeNodeTypeEnum.SOURCE.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "source", offset));
                  if (getSource() != null) {
                     bb = GreenballMessagesUtility.insertString(bb, offset, getSource());
                     offset += length * 1;
                  }
               }
               else if (id == TreeNodeTypeEnum.CROSSLINK.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "crosslink", offset));
                  if (getCrosslink() != null) {
                     bb = GreenballMessagesUtility.insertString(bb, offset, getCrosslink());
                     offset += length * 1;
                  }
               }
               else if (id == TreeNodeTypeEnum.RULE_IDS.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "ruleIds", offset));
                  for (String s : getRuleIds()) {
                     bb = GreenballMessagesUtility.insertString(bb, offset, s);
                     int strLen = s.getBytes(Charset
                           .forName("UTF-8")).length;

                     theDirectory[index].setId(id);
                     theDirectory[index].setLength(strLen);
                     theDirectory[index].setOffset(offset);

                     offset += strLen;
                     index++;
                  }
                  index--;
               }
               else if (id == TreeNodeTypeEnum.CROSS_REFERENCE.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "crossReference", offset));
                  if (getCrossReference() != null) {
                     bb = GreenballMessagesUtility.insertString(bb, offset, getCrossReference());
                     offset += length * 1;
                  }
               }
               else if (id == TreeNodeTypeEnum.ID.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "id", offset));
                  if (getId() != null) {
                     bb = GreenballMessagesUtility.insertString(bb, offset, getId());
                     offset += length * 1;
                  }
               }
               else if (id == TreeNodeTypeEnum.PARENT_ID.getId()) {
                  log4j.debug(String.format("inserting %s at offset %d", "parentId", offset));
                  if (getParentId() != null) {
                     bb = GreenballMessagesUtility.insertString(bb, offset, getParentId());
                     offset += length * 1;
                  }
               }
               index++;
            }
         }

         // Insert the directory
         log4j.debug(String.format("inserting the directory at offset %d", DIRECTORY_OFFSET));
         offset = DIRECTORY_OFFSET;
         index = 0;
         for (GreenballMessagesDirectoryEntry directoryEntry : theDirectory) {
            log4j.debug(String.format("index[%d]: ", index));
            log4j.debug(String.format("  ID:     %d", directoryEntry.getId()));
            log4j.debug(String.format("  length: %d", directoryEntry.getLength()));
            log4j.debug(String.format("  offset: %d", directoryEntry.getOffset()));
            bb = GreenballMessagesUtility.insertInteger(bb, offset, directoryEntry.getId());
            bb = GreenballMessagesUtility.insertInteger(bb, offset + 4, directoryEntry.getLength());
            bb = GreenballMessagesUtility.insertInteger(bb, offset + 8, directoryEntry.getOffset());

            offset += GreenballMessagesDirectoryEntry.DIRECTORY_ENTRY_SIZE_IN_BYTES;
            index++;
         }

      }
      log4j.debug("Leaving " + METHOD);
      return bb;
   }
   // Leaving buildPackMethod()

   // Entered buildUnpackMethod()
   /**
    * This method unpacks a byte array containing a TreeNodeType object.
    *
    * @return The byte array as a TreeNodeType message object.
    */
   public TreeNodeType unpack(byte[] ba) {
      final String METHOD = "unpack()";
      log4j.debug("Entered " + METHOD);

      TreeNodeType treeNodeType = new TreeNodeType();

      treeNodeType.setUsageCounter(GreenballMessagesUtility.getInteger(ba, TreeNodeTypeEnum.USAGE_COUNTER.getOffsetInBits()));
      treeNodeType.setLevel(GreenballMessagesUtility.getInteger(ba, TreeNodeTypeEnum.LEVEL.getOffsetInBits()));
      treeNodeType.setNodeState(GreenballMessagesUtility.getInteger(ba, TreeNodeTypeEnum.NODE_STATE.getOffsetInBits()));
      treeNodeType.setSn(GreenballMessagesUtility.getLong(ba, TreeNodeTypeEnum.SN.getOffsetInBits()));
      treeNodeType.setXref(GreenballMessagesUtility.getBoolean(ba, TreeNodeTypeEnum.XREF.getOffsetInBits()));
      treeNodeType.setMulti(GreenballMessagesUtility.getBoolean(ba, TreeNodeTypeEnum.MULTI.getOffsetInBits()));
      treeNodeType.setLabelable(GreenballMessagesUtility.getBoolean(ba, TreeNodeTypeEnum.LABELABLE.getOffsetInBits()));
      treeNodeType.setExpanded(GreenballMessagesUtility.getBoolean(ba, TreeNodeTypeEnum.EXPANDED.getOffsetInBits()));

      // Get the directory
      int directorySize = getTreeNodeTypeDirectorySize();
      theDirectory = new GreenballMessagesDirectoryEntry[directorySize];
      int dirOffset = DIRECTORY_OFFSET;

      for (int entry = 0 ; entry < directorySize; entry++) {
         GreenballMessagesDirectoryEntry directoryEntry = new GreenballMessagesDirectoryEntry();

         int id = GreenballMessagesUtility.getInteger(ba, dirOffset * 8);
         directoryEntry.setId(id);
         int length = GreenballMessagesUtility.getInteger(ba, (dirOffset + 4) * 8);
         directoryEntry.setLength(length);
         int offset = GreenballMessagesUtility.getInteger(ba, (dirOffset + 8) * 8);
         directoryEntry.setOffset(offset);

         theDirectory[entry] = directoryEntry;

         dirOffset += GreenballMessagesDirectoryEntry.DIRECTORY_ENTRY_SIZE_IN_BYTES;
      }

      for (GreenballMessagesDirectoryEntry directoryEntry : theDirectory) {
         int id = directoryEntry.getId();
         int offset = directoryEntry.getOffset();
         int length = directoryEntry.getLength();

         if (id == TreeNodeTypeEnum.PREFIX.getId()) {
            treeNodeType.setPrefix(GreenballMessagesUtility.getString(ba, offset, length));
         }
         else if (id == TreeNodeTypeEnum.LABEL.getId()) {
            treeNodeType.setLabel(GreenballMessagesUtility.getString(ba, offset, length));
         }
         else if (id == TreeNodeTypeEnum.FIELD_NAME.getId()) {
            treeNodeType.setFieldName(GreenballMessagesUtility.getString(ba, offset, length));
         }
         else if (id == TreeNodeTypeEnum.CLASS_NAME.getId()) {
            treeNodeType.setClassName(GreenballMessagesUtility.getString(ba, offset, length));
         }
         else if (id == TreeNodeTypeEnum.SOURCE.getId()) {
            treeNodeType.setSource(GreenballMessagesUtility.getString(ba, offset, length));
         }
         else if (id == TreeNodeTypeEnum.CROSSLINK.getId()) {
            treeNodeType.setCrosslink(GreenballMessagesUtility.getString(ba, offset, length));
         }
         else if (id == TreeNodeTypeEnum.RULE_IDS.getId()) {
            String s = GreenballMessagesUtility.getString(ba, offset, length);
            treeNodeType.getRuleIds().add(s);
         }
         else if (id == TreeNodeTypeEnum.CROSS_REFERENCE.getId()) {
            treeNodeType.setCrossReference(GreenballMessagesUtility.getString(ba, offset, length));
         }
         else if (id == TreeNodeTypeEnum.ID.getId()) {
            treeNodeType.setId(GreenballMessagesUtility.getString(ba, offset, length));
         }
         else if (id == TreeNodeTypeEnum.PARENT_ID.getId()) {
            treeNodeType.setParentId(GreenballMessagesUtility.getString(ba, offset, length));
         }
         else if (id == TreeNodeTypeEnum.PARENT.getId()) {
            byte[] bytes = new byte[length];

            for (int index = 0; index < length; index++) {
               bytes[index] = GreenballMessagesUtility.getByte(ba, (offset + index) * 8);
            }

            treeNodeType.setParent(new TreeNodeType().unpack(bytes));
         }
         else if (id == TreeNodeTypeEnum.CHILDREN.getId()) {
            byte[] bytes = new byte[length];
            for (int index = 0; index < length; index++) {
               bytes[index] = GreenballMessagesUtility.getByte(ba, (offset + index) * 8);
            }
            treeNodeType.getChildren().add(new TreeNodeType().unpack(bytes));
         }
      }

      log4j.debug("Leaving " + METHOD);
      return treeNodeType;
   }
   // Leaving buildUnpackMethod()

   /**
    * This method sets the prefix attribute. Setting of this value is required.
    * @param prefix The prefix attribute.
    */
   public void setPrefix(String prefix) {
      this.prefix = prefix;
   }

   /**
    * This method sets the label attribute. Setting of this value is required.
    * @param label The label attribute.
    */
   public void setLabel(String label) {
      this.label = label;
   }

   /**
    * This method sets the fieldName attribute. Setting of this value is required.
    * @param fieldName The fieldName attribute.
    */
   public void setFieldName(String fieldName) {
      this.fieldName = fieldName;
   }

   /**
    * This method sets the className attribute. Setting of this value is required.
    * @param className The className attribute.
    */
   public void setClassName(String className) {
      this.className = className;
   }

   /**
    * This method sets the source attribute. Setting of this value is required.
    * @param source The source attribute.
    */
   public void setSource(String source) {
      this.source = source;
   }

   /**
    * This method sets the crosslink attribute. Setting of this value is optional.
    * @param crosslink The crosslink attribute.
    */
   public void setCrosslink(String crosslink) {
      this.crosslink = crosslink;
   }

   /**
    * This method sets the usageCounter attribute. Setting of this value is required.
    * @param usageCounter The usageCounter attribute.
    */
   public void setUsageCounter(Integer usageCounter) {
      this.usageCounter = usageCounter;
   }

   /**
    * This method sets the level attribute. Setting of this value is required.
    * @param level The level attribute.
    */
   public void setLevel(Integer level) {
      this.level = level;
   }

   /**
    * This method sets the nodeState attribute. Setting of this value is required.
    * @param nodeState The nodeState attribute.
    */
   public void setNodeState(Integer nodeState) {
      this.nodeState = nodeState;
   }

   /**
    * This method sets the sn attribute. Setting of this value is required.
    * @param sn The sn attribute.
    */
   public void setSn(Long sn) {
      this.sn = sn;
   }

   /**
    * This method sets the xref attribute. Setting of this value is required.
    * @param xref The xref attribute.
    */
   public void setXref(Boolean xref) {
      this.xref = xref;
   }

   /**
    * This method sets the ruleIds attribute. Setting of this value is optional.
    * @param ruleIds The ruleIds attribute.
    */
   public void setRuleIds(List<String> ruleIds) {
      this.ruleIds = ruleIds;
   }

   /**
    * This method sets the crossReference attribute. Setting of this value is optional.
    * @param crossReference The crossReference attribute.
    */
   public void setCrossReference(String crossReference) {
      this.crossReference = crossReference;
   }

   /**
    * This method sets the multi attribute. Setting of this value is required.
    * @param multi The multi attribute.
    */
   public void setMulti(Boolean multi) {
      this.multi = multi;
   }

   /**
    * This method sets the labelable attribute. Setting of this value is required.
    * @param labelable The labelable attribute.
    */
   public void setLabelable(Boolean labelable) {
      this.labelable = labelable;
   }

   /**
    * This method sets the expanded attribute. Setting of this value is required.
    * @param expanded The expanded attribute.
    */
   public void setExpanded(Boolean expanded) {
      this.expanded = expanded;
   }

   /**
    * This method sets the id attribute. Setting of this value is required.
    * @param id The id attribute.
    */
   public void setId(String id) {
      this.id = id;
   }

   /**
    * This method sets the parentId attribute. Setting of this value is required.
    * @param parentId The parentId attribute.
    */
   public void setParentId(String parentId) {
      this.parentId = parentId;
   }

   /**
    * This method gets the prefix attribute. The prefix attribute is a required attribute.
    */
   public String getPrefix() {
      return this.prefix;
   }

   /**
    * This method gets the label attribute. The label attribute is a required attribute.
    */
   public String getLabel() {
      return this.label;
   }

   /**
    * This method gets the fieldName attribute. The fieldName attribute is a required attribute.
    */
   public String getFieldName() {
      return this.fieldName;
   }

   /**
    * This method gets the className attribute. The className attribute is a required attribute.
    */
   public String getClassName() {
      return this.className;
   }

   /**
    * This method gets the source attribute. The source attribute is a required attribute.
    */
   public String getSource() {
      return this.source;
   }

   /**
    * This method gets the crosslink attribute. The crosslink attribute is an optional attribute.
    */
   public String getCrosslink() {
      return this.crosslink;
   }

   /**
    * This method gets the usageCounter attribute. The usageCounter attribute is a required attribute.
    */
   public Integer getUsageCounter() {
      return this.usageCounter;
   }

   /**
    * This method gets the level attribute. The level attribute is a required attribute.
    */
   public Integer getLevel() {
      return this.level;
   }

   /**
    * This method gets the nodeState attribute. The nodeState attribute is a required attribute.
    */
   public Integer getNodeState() {
      return this.nodeState;
   }

   /**
    * This method gets the sn attribute. The sn attribute is a required attribute.
    */
   public Long getSn() {
      return this.sn;
   }

   /**
    * This method gets the xref attribute. The xref attribute is a required attribute.
    */
   public Boolean getXref() {
      return this.xref;
   }

   /**
    * This method gets the ruleIds attribute. The ruleIds attribute is an optional attribute.
    */
   public List<String> getRuleIds() {
      if (this.ruleIds == null) {
         this.ruleIds = new ArrayList<String>();
      }
      return this.ruleIds;
   }

   /**
    * This method gets the crossReference attribute. The crossReference attribute is an optional attribute.
    */
   public String getCrossReference() {
      return this.crossReference;
   }

   /**
    * This method gets the multi attribute. The multi attribute is a required attribute.
    */
   public Boolean getMulti() {
      return this.multi;
   }

   /**
    * This method gets the labelable attribute. The labelable attribute is a required attribute.
    */
   public Boolean getLabelable() {
      return this.labelable;
   }

   /**
    * This method gets the expanded attribute. The expanded attribute is a required attribute.
    */
   public Boolean getExpanded() {
      return this.expanded;
   }

   /**
    * This method gets the id attribute. The id attribute is a required attribute.
    */
   public String getId() {
      return this.id;
   }

   /**
    * This method gets the parentId attribute. The parentId attribute is a required attribute.
    */
   public String getParentId() {
      return this.parentId;
   }

   /**
    * This method sets the parent attribute. Setting of this value is optional.
    * @param parent The parent.
    */
   public void setParent(TreeNodeType parent) {
      this.parent = parent;
   }

   /**
    * This method sets the children attribute. Setting of this value is required.
    * @param children The children.
    */
   public void setChildren(List<TreeNodeType> children) {
      this.children = children;
   }

   /**
    * This method gets the parent attribute. The parent attribute is an optional attribute.
    */
   public TreeNodeType getParent() {
      return this.parent;
   }

   /**
    * This method gets the children attribute. The children attribute is a required attribute.
    */
   public List<TreeNodeType> getChildren() {
      if (this.children == null) {
         this.children = new ArrayList<TreeNodeType>();
      }
      return this.children;
   }

   /**
    * This method gets the size of the directory.
    */
   private int getTreeNodeTypeDirectorySize() {
      int directorySize = 0;

      // parent
      directorySize++;
      // children
      directorySize += getChildren().size();
      // prefix
      directorySize++;
      // label
      directorySize++;
      // fieldName
      directorySize++;
      // className
      directorySize++;
      // source
      directorySize++;
      // crosslink
      directorySize++;
      // ruleIds
      directorySize += getRuleIds().size();
      // crossReference
      directorySize++;
      // id
      directorySize++;
      // parentId
      directorySize++;

      return directorySize;
   }


   /**
    * This method gets the size of the TreeNodeType object.
    * @return The size in bytes.
    */
   public int getTreeNodeTypeSize() {
      int size = 0;

      int directorySize = getTreeNodeTypeDirectorySize();
      size += directorySize * GreenballMessagesDirectoryEntry.DIRECTORY_ENTRY_SIZE_IN_BYTES;
      // Add size of prefix
      size += (getPrefix() != null ? getPrefix().length() : 0);
      // Add size of label
      size += (getLabel() != null ? getLabel().length() : 0);
      // Add size of fieldName
      size += (getFieldName() != null ? getFieldName().length() : 0);
      // Add size of className
      size += (getClassName() != null ? getClassName().length() : 0);
      // Add size of source
      size += (getSource() != null ? getSource().length() : 0);
      // Add size of crosslink
      size += (getCrosslink() != null ? getCrosslink().length() : 0);
      // Add size of usageCounter
      size += 4;
      // Add size of level
      size += 4;
      // Add size of nodeState
      size += 4;
      // Add size of sn
      size += 8;
      // Add size of xref
      size += 1;
      // Add size of ruleIds
      for (String s : getRuleIds()) {
         size += s.getBytes(Charset.forName("UTF-8")).length;
      }
      // Add size of crossReference
      size += (getCrossReference() != null ? getCrossReference().length() : 0);
      // Add size of multi
      size += 1;
      // Add size of labelable
      size += 1;
      // Add size of expanded
      size += 1;
      // Add size of id
      size += (getId() != null ? getId().length() : 0);
      // Add size of parentId
      size += (getParentId() != null ? getParentId().length() : 0);
      // Add size of parent
      size += getParent().getTreeNodeTypeSize();
      // Add size of children
      for (TreeNodeType treeNodeType: getChildren()) {
         size += treeNodeType.getTreeNodeTypeSize();
      }

      return size;
   }

   @Override
   public String toString() {
      StringBuilder result = new StringBuilder();
      String NEW_LINE = System.getProperty("line.separator");

      result.append(this.getClass().getSimpleName() + " Object {" + NEW_LINE);
      result.append(" parent: " + parent + NEW_LINE);

      if (children != null) {
         for (TreeNodeType childrenTreeNodeType : children) {
            result.append(childrenTreeNodeType.toString());
         }
      }
      result.append(" prefix: " + prefix + NEW_LINE);
      result.append(" label: " + label + NEW_LINE);
      result.append(" fieldName: " + fieldName + NEW_LINE);
      result.append(" className: " + className + NEW_LINE);
      result.append(" source: " + source + NEW_LINE);
      result.append(" crosslink: " + crosslink + NEW_LINE);
      result.append(" usageCounter: " + usageCounter + NEW_LINE);
      result.append(" level: " + level + NEW_LINE);
      result.append(" nodeState: " + nodeState + NEW_LINE);
      result.append(" sn: " + sn + NEW_LINE);
      result.append(" xref: " + xref + NEW_LINE);

      if (ruleIds != null) {
         int i = 0;
         for (String ruleIdsString : ruleIds) {
            result.append(" ruleIds[" + i + "]: " + ruleIdsString.toString() + NEW_LINE);
            i++;
         }
      }
      result.append(" crossReference: " + crossReference + NEW_LINE);
      result.append(" multi: " + multi + NEW_LINE);
      result.append(" labelable: " + labelable + NEW_LINE);
      result.append(" expanded: " + expanded + NEW_LINE);
      result.append(" id: " + id + NEW_LINE);
      result.append(" parentId: " + parentId + NEW_LINE);

      result.append("} ");

      return result.toString();
   }

   /**
    * The hashCode method returns this object's hashCode.
    */
   @Override
   public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result
         + ((String) prefix).hashCode();
      result = prime * result
         + ((String) label).hashCode();
      result = prime * result
         + ((String) fieldName).hashCode();
      result = prime * result
         + ((String) className).hashCode();
      result = prime * result
         + ((String) source).hashCode();
      result = prime * result
         + ((String) crosslink).hashCode();
      result = prime * result
         + ((Integer) usageCounter).hashCode();
      result = prime * result
         + ((Integer) level).hashCode();
      result = prime * result
         + ((Integer) nodeState).hashCode();
      result = prime * result
         + ((Long) sn).hashCode();
      result = prime * result
         + ((Boolean) xref).hashCode();
      for (String s : ruleIds) {
         result = prime * result + s.hashCode();
      }
      result = prime * result
         + ((String) crossReference).hashCode();
      result = prime * result
         + ((Boolean) multi).hashCode();
      result = prime * result
         + ((Boolean) labelable).hashCode();
      result = prime * result
         + ((Boolean) expanded).hashCode();
      result = prime * result
         + ((String) id).hashCode();
      result = prime * result
         + ((String) parentId).hashCode();
      return result;
   }

   /**
    * The equals method checks for equality. 
    */
   public boolean equals(Object obj) {
      if (obj == this) return true;
      if (obj == null) return false;
      if (getClass() != obj.getClass()) return false;

      TreeNodeType treeNodeType = (TreeNodeType) obj;
      if (!treeNodeType.getPrefix().equals(this.getPrefix())) {
         return false;
      }

      if (!treeNodeType.getLabel().equals(this.getLabel())) {
         return false;
      }

      if (!treeNodeType.getFieldName().equals(this.getFieldName())) {
         return false;
      }

      if (!treeNodeType.getClassName().equals(this.getClassName())) {
         return false;
      }

      if (!treeNodeType.getSource().equals(this.getSource())) {
         return false;
      }

      if (treeNodeType.getCrosslink() == null && this.getCrosslink() != null) {
         return false;
      }
      else if (treeNodeType.getCrosslink() != null && this.getCrosslink() == null) {
         return false;
      }
      else if (treeNodeType.getCrosslink() != null && 
      !treeNodeType.getCrosslink().equals(this.getCrosslink())) {
         return false;
      }

      if (treeNodeType.getUsageCounter() != this.getUsageCounter()) {
         return false;
      }

      if (treeNodeType.getLevel() != this.getLevel()) {
         return false;
      }

      if (treeNodeType.getNodeState() != this.getNodeState()) {
         return false;
      }

      if (treeNodeType.getSn() != this.getSn()) {
         return false;
      }

      if (treeNodeType.getXref() != this.getXref()) {
         return false;
      }

      if (treeNodeType.getRuleIds() == null && this.getRuleIds() != null) {
         return false;
      }
      else if (treeNodeType.getRuleIds() != null && this.getRuleIds() == null) {
         return false;
      }
      else if (treeNodeType.getRuleIds() != null && 
      !treeNodeType.getRuleIds().equals(this.getRuleIds())) {
         return false;
      }

      if (treeNodeType.getCrossReference() == null && this.getCrossReference() != null) {
         return false;
      }
      else if (treeNodeType.getCrossReference() != null && this.getCrossReference() == null) {
         return false;
      }
      else if (treeNodeType.getCrossReference() != null && 
      !treeNodeType.getCrossReference().equals(this.getCrossReference())) {
         return false;
      }

      if (treeNodeType.getMulti() != this.getMulti()) {
         return false;
      }

      if (treeNodeType.getLabelable() != this.getLabelable()) {
         return false;
      }

      if (treeNodeType.getExpanded() != this.getExpanded()) {
         return false;
      }

      if (!treeNodeType.getId().equals(this.getId())) {
         return false;
      }

      if (!treeNodeType.getParentId().equals(this.getParentId())) {
         return false;
      }

      return true;
   }
}
