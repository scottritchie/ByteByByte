/*
 * WARNING: This file was generated by BitByBitGenerator.xtend (see
 * generateSubTypeInstantiationFile()).
 * Do not edit.
 */
package com.viacron.greenball.app.bbb;
import java.util.ArrayList;
import java.util.List;

import org.apache.log4j.Logger;

import com.viacron.utils.StringMessageBuffer.parser.AbstractAttribute;
import com.viacron.utils.StringMessageBuffer.parser.Element;
import com.viacron.utils.StringMessageBuffer.parser.KeyValuePair;

public class InstantiateMetaModel1 {
private static Logger log4j = Logger.getLogger(InstantiateMetaModel1.class);

private Element element;
private MetaModel1 metaModel1;

/*
 * The isUpdated flags. If an attribute is required by the grammar then a value
 * must be provided, and the isUpdated flag will be set when the value is
 * obtained during unpacking. After the object is constructed during unpacking, 
 * validation will be performed to make sure a value was provided for all attributes
 * that are not optional. 
 * See buildFlags() in JBitByBitGenerator.java.
 */
private boolean isNameUpdated = false;
private boolean isDatatypeUpdated = false;
private boolean isIncludeUpdated = false;
private boolean isMetaModelElementUpdated = false;

/**
 * This method constructs a InstantiateMetaModel1 object based on an Element
 * object.
 * 
 * @param element
 *            The Element.
 */
public InstantiateMetaModel1(Element element) {
this.element = element;
this.metaModel1 = new MetaModel1();
}

/**
 * The instantiate method instantiates a MetaModel1 object.
 * 
 * @return The MetaModel1.
 */
protected MetaModel1 instantiate() {
final String METHOD = "instantiate()";
log4j.debug("Entered " + METHOD);

log4j.debug("element: " + element.getName());

for (AbstractAttribute abstractAttribute : element.getAbstractAttributes()) {
      // Entered instantiateSubTypeElements()
   for (Element e : abstractAttribute.getElements()) {
      if (e.getName().startsWith("datatype[")) {
         this.isDatatypeUpdated = true;
         log4j.debug("found element: datatype");
         if (metaModel1.getDatatype() == null) {
         List<Datatype> datatype = new ArrayList<Datatype>();
         metaModel1.setDatatype(datatype);
         }

         InstantiateDatatype instantiateDatatype =
                  new InstantiateDatatype(e);
         Datatype datatype =
                  instantiateDatatype.instantiate();
         metaModel1.getDatatype().add(datatype);
      }
      else if (e.getName().startsWith("include[")) {
         this.isIncludeUpdated = true;
         log4j.debug("found element: include");
         if (metaModel1.getInclude() == null) {
         List<Include> include = new ArrayList<Include>();
         metaModel1.setInclude(include);
         }

         InstantiateInclude instantiateInclude =
                  new InstantiateInclude(e);
         Include include =
                  instantiateInclude.instantiate();
         metaModel1.getInclude().add(include);
      }
      else if (e.getName().startsWith("metaModelElement[")) {
         this.isMetaModelElementUpdated = true;
         log4j.debug("found element: metaModelElement");
         if (metaModel1.getMetaModelElement() == null) {
         List<MetaModelElement> metaModelElement = new ArrayList<MetaModelElement>();
         metaModel1.setMetaModelElement(metaModelElement);
         }

         InstantiateMetaModelElement instantiateMetaModelElement =
                  new InstantiateMetaModelElement(e);
         MetaModelElement metaModelElement =
                  instantiateMetaModelElement.instantiate();
         metaModel1.getMetaModelElement().add(metaModelElement);
      }
   }
   // Leaving instantiateSubTypeElements()


   for (KeyValuePair kvp : abstractAttribute.getKeyValuePairs()) {
         // Entered instantiateSubTypeAttributes()
   if (kvp.getKey().equals("name")) {
    this.isNameUpdated = true;
   log4j.debug("setting value of \"name\" to: " + kvp.getValue());
   metaModel1.setName(kvp.getValue());
   }
   // Leaving instantiateSubTypeAttributes()

   }
}

log4j.debug("Leaving " + METHOD);
return metaModel1;
}

/**
 * The validate method checks that a value was provided for all required 
 * attributes.
 *
 * @return The error message or null if no error occurred.
 */
protected String validate() {
final String METHOD = "validate()";
log4j.debug("Entered " + METHOD);

String result = null;

// Entered buildValidationMethod()
if (!this.isNameUpdated) {
   String msg = "Name is required, but no value was provided.";
   if (result == null) {
      result = msg;
   }
}

if (!this.isDatatypeUpdated) {
   String msg = "Datatype is required, but no value was provided.";
   if (result == null) {
      result = msg;
   }
   else {
      result = result.concat("\n" + msg);
   }
}

if (!this.isIncludeUpdated) {
   String msg = "Include is required, but no value was provided.";
   if (result == null) {
      result = msg;
   }
   else {
      result = result.concat("\n" + msg);
   }
}

if (!this.isMetaModelElementUpdated) {
   String msg = "MetaModelElement is required, but no value was provided.";
   if (result == null) {
      result = msg;
   }
   else {
      result = result.concat("\n" + msg);
   }
}


if (result != null) {
   log4j.debug("result: " + result);
}

log4j.debug("Leaving " + METHOD);
return result;
}
}
